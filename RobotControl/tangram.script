def tangram():
  global _hidden_verificationVariable=0
  step_count_f37a2128_4902_4b5d_ab63_599b10f4a2e3 = 0.0
  thread Step_Counter_Thread_c9343d06_b429_4025_9dae_54bab750e16d():
    while (True):
      step_count_f37a2128_4902_4b5d_ab63_599b10f4a2e3 = step_count_f37a2128_4902_4b5d_ab63_599b10f4a2e3 + 1.0
      sync()
    end
  end
  run Step_Counter_Thread_c9343d06_b429_4025_9dae_54bab750e16d()
  set_standard_analog_input_domain(0, 1)
  set_standard_analog_input_domain(1, 1)
  set_tool_analog_input_domain(0, 1)
  set_tool_analog_input_domain(1, 1)
  set_analog_outputdomain(0, 0)
  set_analog_outputdomain(1, 0)
  set_input_actions_to_default()
  set_tool_communication(True, 115200, 0, 1, 1.5, 3.5)
  set_tool_output_mode(0)
  set_tool_digital_output_mode(0, 1)
  set_tool_digital_output_mode(1, 1)
  set_tool_voltage(24)
  set_safety_mode_transition_hardness(1)
  set_target_payload(1.130000, [0.000000, 0.003000, 0.056000], [0.001887, 0.001887, 0.001887, 0.000000, 0.000000, 0.000000])
  set_tcp(p[0.0,0.0,0.165,0.0,0.0,0.0])
  set_gravity([0.0, 0.0, 9.82])
  global Point_1=p[0.5673228734564902,-0.15694942793737932,0.5880304365120631,2.355554465134238,0.008459267052315513,-0.015313913082596288]
  global arucoPoS=p[0.14358606805362914,-0.5346312812726187,0.020062451119090552,-0.006999999999967311,-0.0059999999999720876,0.001999999999990575]
  global camera_point=p[0.5673249908663925,-0.15696842591057447,0.5880212097475621,2.3555427745427924,0.008487370770348553,-0.015384853854997254]
  global camera_point2=p[0.10123278156260447,-0.4515073879051816,0.4301420421424132,1.7676376582689655,-1.7499511781911048,-0.7248346176612988]
  global taskBoard=p[0.48286366852174956,0.05992883140279061,0.08331804067154605,0.002374949468008684,-0.006510387070844624,-1.5766474783914255]
  global test1=p[0.45003206386959066,-0.2999499528158499,0.20999121440538393,-3.141566624418454,-4.816541474704348E-5,1.150834355116071E-4]
  global test1plane=p[0.5146664368135077,0.04117677725515298,0.08532718099220993,-0.003603254358429996,0.0030642440845744627,-1.5683532247684813]
  global test2=p[0.44999142377706547,0.14999594978148376,0.20998821534501955,3.1415660103821974,-1.6469533416101298E-4,-1.5501713552265408E-4]
  global test2plane=p[0.32530081172265923,-0.3536937209422928,0.1672875091745058,0.005641910886239387,0.03385723378183954,-1.140209443809353]
  global transPlane=p[0.13202215668383815,-0.5497567930601044,0.019138412390539178,0.005685597373641585,-0.0019228846539893958,0.002890718331601037]
  # begin: URCap Installation Node
  #   Source: External Control, 1.0.5, FZI Research Center for Information Technology
  #   Type: External Control
  # end: URCap Installation Node
  # begin: URCap Installation Node
  #   Source: rs485, 1.0.0, FZI Research Center for Information Technology
  #   Type: RS485
  global rs485=rpc_factory("xmlrpc", "http://127.0.0.1:40404/RPC2")
  # end: URCap Installation Node
  # begin: URCap Installation Node
  #   Source: Robotiq_Grippers, 3.19.1.111718, Robotiq Inc.
  #   Type: Vacuum
  #################################################
  # Vacuum Grip Check
  #################################################
  
  vacuumGripCheckThread1 = 0
  vacuumGripCheckThread2 = 0
  vacuumGripCheckThread3 = 0
  vacuumGripCheckThread4 = 0
  vacuumGripCheckThread1Running = False
  vacuumGripCheckThread2Running = False
  vacuumGripCheckThread3Running = False
  vacuumGripCheckThread4Running = False
  vacuumGripCheckslave_id = 1
  vacuumGripCheckThreadStarted = False
  
  thread vacuumGripCheck():
    slave_id = vacuumGripCheckslave_id
    vacuumGripCheckThreadStarted = True
  
    while (True):
      objectDetectedDebounceCtr = 0
  
      while (objectDetectedDebounceCtr < 3):
        if(rq_is_vacuum_obj_detected_by_slave_id(slave_id=9)):
          objectDetectedDebounceCtr = objectDetectedDebounceCtr + 1
        else:
          objectDetectedDebounceCtr = 0
        end
        sleep(0.1)
      end
  
      objectNotDetectedDebounceCtr = 0
  
      while objectNotDetectedDebounceCtr < 3:
        if (not rq_is_vacuum_obj_detected_by_slave_id(slave_id=9)):
          objectNotDetectedDebounceCtr = objectNotDetectedDebounceCtr + 1
        else:
          objectNotDetectedDebounceCtr = 0
        end
        sleep(0.1)
      end
  
      socket_open("127.0.0.1",29999,"dashboardServerSocket")
      socket_send_line("pause","dashboardServerSocket")
      socket_send_string("popup Vacuum grip check has detected an object drop.", "dashboardServerSocket")
      socket_send_byte(10, "dashboardServerSocket")
      socket_close("dashboardServerSocket")
  
      sleep(0.008)
    end
  end
  
  def startVacuumGripCheckThread(slave_id=9):
    vacuumGripCheckslave_id = slave_id
    threadHandle = run vacuumGripCheck()
    waitForVacuumGripCheckThreadStarted()
    return threadHandle
  end
  
  def stopVacuumGripCheckThread(threadHandle):
    kill threadHandle
  end
  
  def waitForVacuumGripCheckThreadStarted():
    while (not(vacuumGripCheckThreadStarted)):
      sleep(0.008)
    end
    vacuumGripCheckThreadStarted = False
  end
  #################################################
  # End - Vacuum Grip Check
  #################################################
  
  #################################################
  # Stops the pump on a distance travelled
  #################################################
  global stopPumpDistance = 100
  global stopPumpslave_id = 0
  global stopPumpThreadStarted = [False, False, False, False]
  global stopPumpThreadHandles = [0, 0, 0, 0]
  
  thread stopPumpOnDistanceTravelled():
    distance = stopPumpDistance
    slave_id = stopPumpslave_id
    stopPumpThreadStarted[rq_slave_id_to_index(slave_id)] = True
  
    measuredDistance = waitForDistanceTravelled(distance)
  
    rq_stop(slave_id_to_gripper_socket(slave_id))
  
    stopPumpThreadStarted[rq_slave_id_to_index(slave_id)] = False
  end
  
  def waitForDistanceTravelled(distance):
    startingPose = get_actual_tcp_pose()
    measuredDistance = 0
    while (measuredDistance < distance):
      sleep(0.1)
      measuredDistance = point_dist(get_actual_tcp_pose(), startingPose)
    end
  
    return measuredDistance
  end
  
  def startStopPumpOnDistanceTravelledThread(distance, slave_id=9):
    if (stopPumpThreadStarted[rq_slave_id_to_index(slave_id)]):
      return 0
    end
  
    global stopPumpDistance = distance
    global stopPumpslave_id = slave_id
    stopPumpThreadHandles[rq_slave_id_to_index(slave_id)] = run stopPumpOnDistanceTravelled()
    waitForStopPumpOnDistanceTravelledThreadStarted(slave_id)
    return stopPumpThreadHandles[rq_slave_id_to_index(slave_id)]
  end
  
  def waitForStopPumpOnDistanceTravelledThreadStarted(slave_id=9):
    while (not(stopPumpThreadStarted[rq_slave_id_to_index(slave_id)])):
      sleep(0.008)
    end
  end
  
  def stopStopPumpOnDistanceTravelledThread(slave_id=9):
    handle = stopPumpThreadHandles[rq_slave_id_to_index(slave_id)]
    threadIsRunning = stopPumpThreadStarted[rq_slave_id_to_index(slave_id)]
    if (threadIsRunning):
      kill handle
      stopPumpThreadHandles[rq_slave_id_to_index(slave_id)] = 0
    end
  end
  #################################################
  # End - Stops the pump on a distance travelled
  #################################################
  
  #################################################
  # Vacuum general functions
  #################################################
  def rq_wait_for_vacuum_object_detected(slave_id=9):
      while (not rq_is_vacuum_obj_detected_by_slave_id(slave_id)):
          if (rq_is_vacuum_timeout(slave_id)):
              return False
          end
          sleep(0.008)
      end
      return True
  end
  
  def rq_wait_for_vacuum_object_secured(slave_id=9):
      while (not rq_is_vacuum_obj_secured(slave_id)):
          if (rq_is_vacuum_timeout(slave_id)):
              return False
          end
          sleep(0.008)
      end
      return True
  end
  
  def rq_wait_for_vacuum_object_suction_complete(slave_id=9):
      remaining_retries = 50
  
       # Wait for suction started
      while (not rq_is_vacuum_obj_in_suction(slave_id) and
             not rq_is_vacuum_obj_detected_by_slave_id(slave_id) and
             remaining_retries > 0):
          sleep(0.01)
          remaining_retries = remaining_retries - 1
      end
  
      # Wait for suction completed
      while (rq_is_vacuum_obj_in_suction(slave_id)):
          if (rq_is_vacuum_timeout(slave_id)):
              return False
          end
          sleep(0.01)
      end
  
      return True
  end
  
  def rq_wait_for_vacuum_object_not_detected(slave_id=9):
      while (rq_is_vacuum_obj_detected_by_slave_id(slave_id)):
          sleep(0.01)
      end
  end
  
  def rq_is_vacuum_obj_detected_by_slave_id(slave_id=9):
      gOBJ = driver_gripper_client.getObjectDetectionFlag(slave_id)
      return is_vacuum_OBJ_object_detected(gOBJ)
  end
  
  def rq_is_vacuum_obj_detected(gripper_socket="1"):
      slave_id = gripper_socket_to_slave_id(gripper_socket)
      return rq_is_vacuum_obj_detected_by_slave_id(slave_id)
  end
  
  def rq_is_vacuum_obj_secured(slave_id=9):
      gOBJ = driver_gripper_client.getObjectDetectionFlag(slave_id)
      return is_vacuum_OBJ_object_secured(gOBJ)
  end
  
  def rq_is_vacuum_obj_in_suction(slave_id=9):
      gOBJ = driver_gripper_client.getObjectDetectionFlag(slave_id)
      return is_vacuum_OBJ_object_in_motion(gOBJ)
  end
  
  def rq_is_vacuum_timeout(slave_id=9):
      gFLT = driver_gripper_client.getFault(slave_id)
      return gFLT == 6
  end
  
  def is_vacuum_OBJ_object_in_motion(gOBJ):
      return gOBJ == 0
  end
  
  def is_vacuum_OBJ_object_detected(gOBJ):
      return gOBJ == 1 or gOBJ == 2
  end
  
  def is_vacuum_OBJ_object_secured(gOBJ):
      return gOBJ == 2
  end
  
  def rq_set_vacuum_and_wait(pressure, timeout, minimum, advanced_mode, slave_id=9):
      driver_gripper_client.configureVacuum(slave_id, advanced_mode, pressure, minimum, timeout)
  end
  
  def is_continuous_grip(maximum_vacuum):
    return maximum_vacuum == 0
  end
  
  def rq_vacuum_release(advanced_mode=False, shutoff_distance_cm=5, wait_for_object_released=True, gripper_socket="1"):
    rq_wait_for_gripper_reconnection()
    local slave_id = gripper_socket_to_slave_id(gripper_socket)
    local shutoff_distance = scale(shutoff_distance_cm, [0, 99], [0.00, 0.99])
    local pressure = 255
    local minimum = 0
    local timeout = 255
    rq_vacuum_release_raw(advanced_mode, pressure, minimum, timeout, shutoff_distance, wait_for_object_released, slave_id)
  end
  
  def rq_vacuum_release_raw(advanced_mode, pressure, minimum, timeout, shutoff_distance, wait_for_object_released, slave_id):
    rq_reset_fault_and_activate(slave_id)
  
    if advanced_mode:
      rq_set_vacuum_and_wait(pressure, timeout, minimum, 1, slave_id)
    else:
      rq_set_vacuum_and_wait(pressure, timeout, minimum, 0, slave_id)
    end
  
    # The following patch is for Robotiq's Camera issue when communication is lost, but not the activation
    # the communication driver reset the GTO bit
    driver_gripper_client.goto(slave_id, 1)
  
    if wait_for_object_released:
      while (rq_is_vacuum_obj_detected_by_slave_id(slave_id)):
  
        if advanced_mode:
          rq_set_vacuum_and_wait(pressure, timeout, minimum, 1, slave_id)
        else:
          rq_set_vacuum_and_wait(pressure, timeout, minimum, 0, slave_id)
        end
  
        # The following patch is for Robotiq's Camera issue when communication is lost, but not the activation
        # the communication driver reset the GTO bit
        driver_gripper_client.goto(slave_id, 1)
        sleep(0.01)
      end
    end
  
    if advanced_mode:
      startStopPumpOnDistanceTravelledThread(shutoff_distance, slave_id)
    end
  end
  
  def rq_vacuum_grip(advanced_mode=False, maximum_vacuum=60, minimum_vacuum=40, timeout_ms=3000, wait_for_object_detected=True, gripper_socket="1"):
    rq_wait_for_gripper_reconnection()
    local slave_id = gripper_socket_to_slave_id(gripper_socket)
    local pressure = floor(scale(maximum_vacuum, [0, 100], [100, 0]))
    local minimum = floor(scale(minimum_vacuum, [0, 100], [100, 0]))
    local timeout = floor(scale(timeout_ms, [0, 25500], [0, 255]))
    rq_vacuum_grip_raw(advanced_mode, pressure, minimum, timeout, slave_id)
    if wait_for_object_detected:
          suction_completed = rq_wait_for_vacuum_object_suction_complete(slave_id)
          if(not suction_completed):
            driver_gripper_client.goto(slave_id, 0)
          end
    end
  end
  
  def rq_vacuum_grip_raw(advanced_mode, pressure, minimum, timeout, slave_id):
    stopStopPumpOnDistanceTravelledThread(slave_id)
    rq_reset_fault_and_activate(slave_id)
  
    if advanced_mode:
      rq_set_vacuum_and_wait(pressure, timeout, minimum, 1, slave_id)
    else:
      rq_set_vacuum_and_wait(pressure, timeout, minimum, 0, slave_id)
    end
  
    driver_gripper_client.goto(slave_id, 1)
  end
  
  def is_FLT_no_fault(gFLT):
      return gFLT == 0
  end
  
  def is_FLT_vacuum_timeout(gFLT):
    return gFLT == 6
  end
  
  def is_FLT_faulted(gFLT):
      return gFLT >= 8
  end
  
  def rq_reset_fault_and_activate(slave_id):
      gFLT = driver_gripper_client.getFault(slave_id)
  
      if(not is_FLT_no_fault(gFLT)):
          if(is_FLT_vacuum_timeout(gFLT)):
              driver_gripper_client.goto(slave_id, 0)
          elif(is_FLT_faulted(gFLT)):
              driver_gripper_client.goto(slave_id, 0)
              driver_gripper_client.activate([slave_id], True)
          end
      elif(not rq_is_gripper_activated(slave_id)):
          driver_gripper_client.goto(slave_id, 0)
          driver_gripper_client.activate([slave_id], False)
      end
  end
  #################################################
  # End - Vacuum general functions
  #################################################
    def scale(value, rawRange, scaledRange):
        def computeSlope(inputRange, outputRange):
            outputRangeDelta = outputRange[1] - outputRange[0]
            inputRangeDelta = inputRange[1] - inputRange[0]

            if (inputRangeDelta == 0):
                return 0
            else:
                return outputRangeDelta / inputRangeDelta
            end
        end

        def computeIntercept(slope, inputRange, outputRange):
            return outputRange[0] - (slope * inputRange[0])
        end

        def clipScaledValue(outputScaledValue, outputRange):
            if (outputRange[0] < outputRange[1]):
                return clipWhenLowerLimitIsLessThanHigher(outputScaledValue, outputRange)
            else:
                return clipWhenLowerLimitIsGreaterThanHigherLimit(outputScaledValue, outputRange)
            end
        end

        def clipWhenLowerLimitIsGreaterThanHigherLimit(outputScaledValue, outputRange):
            if (outputScaledValue < outputRange[1]):
                return outputRange[1]
            elif (outputScaledValue > outputRange[0]):
                return outputRange[0]
            else:
                return outputScaledValue
            end
        end

        def clipWhenLowerLimitIsLessThanHigher(outputScaledValue, outputRange):
            if (outputScaledValue < outputRange[0]):
                return outputRange[0]
            elif (outputScaledValue > outputRange[1]):
                return outputRange[1]
            else:
                return outputScaledValue
            end
        end

        slope = computeSlope(rawRange, scaledRange)
        intercept = computeIntercept(slope, rawRange, scaledRange)
        scaledValue = slope * value + intercept
        return clipScaledValue(scaledValue, scaledRange)
    end

    def limit(value, range):
        return scale(value, range, range)
    end

  vacuumGripCheckWarningTitle = "Vacuum grip check"
  vacuumGripCheckWarningMessage = "Vacuum gripper object lost"
  vacuumGripTimeoutTitle = "Vacuum gripper fault"
  vacuumGripTimeoutMessage = "Grip has timed out"
  # end: URCap Installation Node
  # begin: URCap Installation Node
  #   Source: Robotiq_Grippers, 3.19.1.111718, Robotiq Inc.
  #   Type: Gripper
  RQ_UNIT_PERCENT = 0
  RQ_UNIT_MM = 1
  RQ_UNIT_INCH = 2
  
  global gripper_reconnecting = False
  rq_current_limit_enabled = False
  gripper_closed_norm = [100, 100, 100, 100]
  gripper_open_norm = [0, 0, 0, 0]
  gripper_closed_mm = [0, 0, 0, 0]
  gripper_open_mm = [50, 50, 50, 50]
  
  driver_gripper_client = rpc_factory("xmlrpc","http://127.0.0.1:63353")
  
  def rq_set_force_norm(force_norm, gripper_socket="1"):
      rq_wait_for_gripper_reconnection()
      slave_id = gripper_socket_to_slave_id(gripper_socket)
      rq_set_force_norm_multi_grippers(force_norm, [slave_id])
  end
  
  def rq_set_force_norm_multi_grippers(force_norm, slave_ids=[9]):
      driver_gripper_client.setForce(slave_ids, force_norm)
  end
  
  def rq_set_speed_norm(speed_norm, gripper_socket="1"):
      rq_wait_for_gripper_reconnection()
      slave_id = gripper_socket_to_slave_id(gripper_socket)
      rq_set_speed_norm_multi_grippers(speed_norm, [slave_id])
  end
  
  def rq_set_speed_norm_multi_grippers(speed_norm, slave_ids=[9]):
      driver_gripper_client.setSpeed(slave_ids, speed_norm)
  end
  
  def rq_open_and_wait(gripper_socket="1"):
      rq_wait_for_gripper_reconnection()
      slave_id = gripper_socket_to_slave_id(gripper_socket)
      driver_gripper_client.openGripper(slave_id)
      rq_wait_for_motion_complete([slave_id])
  end
  
  def rq_close_and_wait(gripper_socket="1"):
      rq_wait_for_gripper_reconnection()
      slave_id = gripper_socket_to_slave_id(gripper_socket)
      driver_gripper_client.closeGripper(slave_id)
      rq_wait_for_motion_complete([slave_id])
  end
  
  def rq_move_norm_multi_grippers(position, slave_ids=[9]):
     # rq_wait_for_gripper_reconnection fucntion is not called here because it is already done in the gripper contribution
     # script and this function is not defined for public usage.
     all_gripper_limits = get_all_gripper_limits(slave_ids)
     driver_gripper_client.move(slave_ids, position, RQ_UNIT_PERCENT, all_gripper_limits)
  end
  
  def rq_move_and_wait_norm_multi_grippers(position, slave_ids=[9]):
       all_gripper_limits = get_all_gripper_limits(slave_ids)
       driver_gripper_client.move(slave_ids, position, RQ_UNIT_PERCENT, all_gripper_limits)
       rq_wait_for_motion_complete(slave_ids)
  end
  
  def rq_move_and_wait(position, unit, gripper_socket="1"):
     rq_wait_for_gripper_reconnection()
     slave_id = gripper_socket_to_slave_id(to_str(gripper_socket))
     all_gripper_limits = get_all_gripper_limits([slave_id])
     driver_gripper_client.move([slave_id], position, unit, all_gripper_limits)
     rq_wait_for_motion_complete([slave_id])
  end
  
  def rq_move_and_wait_norm(position, gripper_socket="1"):
      rq_move_and_wait(position, RQ_UNIT_PERCENT, gripper_socket)
  end
  
  def rq_move_and_wait_mm(position, gripper_socket="1"):
      rq_move_and_wait(position, RQ_UNIT_MM, gripper_socket)
  end
  
  def rq_move_and_wait_inches(position, gripper_socket="1"):
     rq_move_and_wait(position, RQ_UNIT_INCH, gripper_socket)
  end
  
  def rq_is_object_detected(gripper_socket="1"):
     slave_id = gripper_socket_to_slave_id(gripper_socket)
     return driver_gripper_client.isObjectDetected(slave_id)
  end
  
  def rq_current_pos_norm(gripper_socket="1"):
      slave_id = gripper_socket_to_slave_id(gripper_socket)
      gripper_limits = get_gripper_limits(gripper_socket)
      return driver_gripper_client.getCurrentPosition(slave_id,
                                    RQ_UNIT_PERCENT,
                                    gripper_limits[0],
                                    gripper_limits[1],
                                    gripper_limits[2],
                                    gripper_limits[3])
  end
  
  def rq_current_pos_mm(gripper_socket=1):
      slave_id = gripper_socket_to_slave_id(to_str(gripper_socket))
      gripper_limits = get_gripper_limits(to_str(gripper_socket))
      return driver_gripper_client.getCurrentPosition(slave_id,
                                    RQ_UNIT_MM,
                                    gripper_limits[0],
                                    gripper_limits[1],
                                    gripper_limits[2],
                                    gripper_limits[3])
  end
  
  def rq_current_pos_inches(gripper_socket=1):
      slave_id = gripper_socket_to_slave_id(to_str(gripper_socket))
      gripper_limits = get_gripper_limits(to_str(gripper_socket))
      return driver_gripper_client.getCurrentPosition(slave_id,
                                    RQ_UNIT_INCH,
                                    gripper_limits[0],
                                    gripper_limits[1],
                                    gripper_limits[2],
                                    gripper_limits[3])
  end
  
  def rq_reset(gripper_socket="1"):
      slave_id = gripper_socket_to_slave_id(gripper_socket)
      driver_gripper_client.deactivate([slave_id])
  end
  
  def rq_set_gripper_max_cur(current_mA, gripper_socket="1"):
      rq_wait_for_gripper_reconnection()
      slave_id = gripper_socket_to_slave_id(gripper_socket)
      driver_gripper_client.setMaximumCurrent(current_mA, slave_id)
  end
  
  def rq_get_gripper_max_cur(gripper_socket="1"):
      slave_id = gripper_socket_to_slave_id(gripper_socket)
      return driver_gripper_client.getMaximumCurrent(slave_id)
  end
  
  def rq_set_max_current_for_all_grippers():
      rq_wait_for_gripper_reconnection()
      driver_gripper_client.setMaximumCurrentOnAllGrippers(rq_current_limit_enabled)
  end
  
  def rq_is_gripper_activated(slave_id=9):
      return driver_gripper_client.isGripperActivated(slave_id)
  end
  
  def rq_is_gripper_connected(slave_id=9):
      return driver_gripper_client.isGripperConnected(slave_id)
  end
  
  def rq_get_fault(slave_id=9):
      return driver_gripper_client.getFault(slave_id)
  end
  
  def rq_activate_and_wait(gripper_socket="1"):
      slave_id = gripper_socket_to_slave_id(gripper_socket)
      if (not rq_is_gripper_activated(slave_id)):
        driver_gripper_client.activate([slave_id], False)
      end
  end
  
  def rq_activate_all_grippers(reset=False):
      empty_array_used_to_act_on_all_grippers = []
      if (reset):
        driver_gripper_client.activate(empty_array_used_to_act_on_all_grippers, True)
      else:
        driver_gripper_client.activateIfRequired(empty_array_used_to_act_on_all_grippers)
      end
  end
  
  def get_closed_norm(gripper_socket):
      return gripper_closed_norm[rq_gripper_socket_to_index(gripper_socket)]
  end
  
  def get_open_norm(gripper_socket):
      return gripper_open_norm[rq_gripper_socket_to_index(gripper_socket)]
  end
  
  def get_open_mm(gripper_socket):
      return gripper_open_mm[rq_gripper_socket_to_index(gripper_socket)]
  end
  
  def get_closed_mm(gripper_socket):
      return gripper_closed_mm[rq_gripper_socket_to_index(gripper_socket)]
  end
  
  def set_closed_norm(closed_norm, gripper_socket):
      gripper_closed_norm[rq_gripper_socket_to_index(gripper_socket)] = closed_norm
  end
  
  def set_open_norm(open_norm, gripper_socket):
      gripper_open_norm[rq_gripper_socket_to_index(gripper_socket)] = open_norm
  end
  
  def set_closed_mm(closed_mm, gripper_socket):
      gripper_closed_mm[rq_gripper_socket_to_index(gripper_socket)] = closed_mm
  end
  
  def set_open_mm(opened_mm, gripper_socket):
      gripper_open_mm[rq_gripper_socket_to_index(gripper_socket)] = opened_mm
  end
  
  def slave_id_to_gripper_socket(slave_id):
      if slave_id == 9:
          return "1"
      else:
          return to_str(slave_id)
      end
  end
  
  def gripper_socket_to_slave_id(gripper_socket):
      if gripper_socket == "1":
          return 9
      else:
          return to_num(gripper_socket)
      end
  end
  
  def rq_slave_id_to_index(slave_id):
      if slave_id == 9:
          return 0
      else:
          return slave_id - 1
      end
  end
  
  def rq_gripper_socket_to_index(gripper_socket):
      return to_num(gripper_socket) - 1
  end
  
  def get_all_gripper_limits(slave_ids):
     all_gripper_limits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
     nb_slave_ids = get_list_length(slave_ids)
     slave_id_index = 0
     index = 0
     sub_index = 0
     while (index < nb_slave_ids):
         slave_id_index = 0
         items_per_limit = 4
         gripper_socket = slave_id_to_gripper_socket(slave_ids[index])
         gripper_limits = get_gripper_limits(gripper_socket)
         while (sub_index < items_per_limit):
            all_gripper_limits[index] = gripper_limits[sub_index]
            sub_index = sub_index + 1
            index = index + 1
         end
         index = index + 1
     end
  
     return all_gripper_limits
  end
  
  def get_gripper_limits(gripper_socket):
      return [get_closed_norm(gripper_socket),
              get_open_norm(gripper_socket),
              get_closed_mm(gripper_socket),
              get_open_mm(gripper_socket)]
  end
  
  def rq_wait_for_motion_complete(slave_ids):
      nb_slave_ids = get_list_length(slave_ids)
      index = 0
      while (index < nb_slave_ids):
        rq_wait(slave_ids[index])
        index = index + 1
      end
  end
  
  def rq_stop(gripper_socket="1"):
      slave_id = gripper_socket_to_slave_id(gripper_socket)
      driver_gripper_client.goto(slave_id, 0)
  end
  
  def rq_wait(slave_id):
      # Wait for the gripper motion to complete
      while (not rq_is_motion_complete(slave_id)):
          # The following patch is for Robotiq's Camera issue when communication is lost, but not the activation
          # the communication driver reset the GTO bit
          driver_gripper_client.goto(slave_id, 1)
          sleep(0.1)
      end
  end
  
  def rq_is_motion_complete(slave_id):
      detection_flag = driver_gripper_client.getObjectDetectionFlag(slave_id)
      return detection_flag > 0 and detection_flag < 4
  end
  
  def write_error_popup(index, message_part_1, message_part_2, title):
      popup_message_part_1 = str_cat(message_part_1, index)
      popup_message_part_2 = str_cat(popup_message_part_1, " ")
      popup_message = str_cat(popup_message_part_2, message_part_2)
      return popup(popup_message, title, False, True, True)
  end
  
  def rq_disconnect_grippers():
      driver_gripper_client.pauseAndDisconnect()
  end
  
  def rq_reconnect_grippers(blocking=False, slave_ids=[]):
      if blocking:
          global gripper_reconnecting = True
          driver_gripper_client.reconnectAndResume(slave_ids)
          gripper_reconnecting = False
      else:
          thread recon_thread():
              rq_reconnect_grippers(True)
              return False
          end
          thrd = run recon_thread()
      end
  end
  
  def rq_wait_for_gripper_reconnection(timeout_s = 30.0):
      while (gripper_reconnecting == True):
          if (timeout_s <= 0):
            popup("Gripper has not reconnected before the expected time")
            halt
          else:
            sync()
            timeout_s = timeout_s - get_steptime()
          end
      end
  end
  
  def rq_gripper_allow_tool_com(allow_tool_comm):
      driver_gripper_client.allowToolComm(allow_tool_comm)
  end
  set_closed_norm(100.0, "1")
  set_open_norm(0.0, "1")
  set_closed_mm(0.0, "1")
  set_open_mm(50.0, "1")
  set_closed_norm(100.0, "2")
  set_open_norm(0.0, "2")
  set_closed_mm(0.0, "2")
  set_open_mm(50.0, "2")
  set_closed_norm(100.0, "3")
  set_open_norm(0.0, "3")
  set_closed_mm(0.0, "3")
  set_open_mm(50.0, "3")
  set_closed_norm(100.0, "4")
  set_open_norm(0.0, "4")
  set_closed_mm(0.0, "4")
  set_open_mm(50.0, "4")
  rq_current_limit_enabled = False
  # end: URCap Installation Node
  # begin: URCap Installation Node
  #   Source: PART LOCALIZATION WITH SICK PLOC2D, 3.0.0.100, SICK AG - Developed by Nimalendiran Kailasanathan
  #   Type: PLOC2D HELP
  global PLOC2D_CONNECTION = "NOT CONNECTED"
  global ANYFEEDER_CONNECTION = "NOT CONNECTED"
  global PLOC2D_STATUS = "Job(s) not located."
  global PLOC_LOCATED = False
  global PLOC_IS_WITHIN_REACH = False
  global PLOC2D_JOB_ID = 0
  global PLOC2D_LOCATE_TRIALS = 0
  global PLOC2D_URPose = p[0,0,0,0,0,0]
   def ploc2d_wrist(pose,jRefPose,activeTCP):
			jJoints=get_inverse_kin(pose,jRefPose,1e-10,1e-10,activeTCP)
			return jJoints
	end
   def ploc_wrist_pose(pose,jRefPose,activeTCP):
			jJoints=get_inverse_kin(pose,jRefPose,1e-10,1e-10,activeTCP)
			finalPose=get_forward_kin(jJoints,activeTCP)
			return finalPose
	end
		def PLOC2D_SendString(PLOC2D_string): #Function to send a string over the socket. INPUT: string to send 
			PLOC2D_sent=False 
			#textmsg("string",PLOC2D_string) 
			PLOC2D_sent=socket_send_line(PLOC2D_string, "Sick_Ploc_Socket") 
			sleep(0.01)  
			if not PLOC2D_sent: 
	  			popup("Failed to send string message","Message Transmission Failure",False,True,blocking=True)  
			end 
		end 
		def PLOC2D_SendStringToAnyfeeder(PLOC2D_AnyfeederString): #Function to send a string over the socket. INPUT: string to send 
			PLOC2D_AnyfeederSent=False 
			#textmsg("string",PLOC2D_AnyfeederString) 
			PLOC2D_AnyfeederSent=socket_send_string(PLOC2D_AnyfeederString, "Anyfeeder_Socket") 
			sleep(0.01)  
			if not PLOC2D_AnyfeederSent: 
	  			popup("Failed to send string message","Message Transmission Failure",False,True,blocking=True)  
			end 
		end 
		def PLOC2D_convertPose(PoseFromPLOC): #Function to convert the frames from a list with millimiters, and RPY angles in degrees data (as returned by PLOC2D_) to a pose variable (meters, radians, axis angle notation) as used by the UR robot. INPUT=list (length 6) with frame format from PLOC2D_ (mm, RPY angles in degrees). OUTPUT=UR robot pose. 
			PLOC2D_rotRPY=[0,0,0] 
			PLOC2D_rotRPY[0]=d2r(PoseFromPLOC[5])  #Rx 
			PLOC2D_rotRPY[1]=d2r(PoseFromPLOC[6])  #Ry 
			PLOC2D_rotRPY[2]=d2r(PoseFromPLOC[7])  #Rz 
			PLOC2D_rotVec=rpy2rotvec(PLOC2D_rotRPY) 
			PLOC2D_convertedPose=p[PoseFromPLOC[2]/1000,PoseFromPLOC[3]/1000,PoseFromPLOC[4]/1000,PLOC2D_rotVec[0],PLOC2D_rotVec[1],PLOC2D_rotVec[2]] 
			return PLOC2D_convertedPose 
		end 
		def PLOC2D_LocatePart(PLOC2D_command): #Function to ask PLOC2D_ to locate a part. INPUT= string PLOC2D_ job Alias. OUTPUT=list with received part result data 
			#PLOC2D_command = "Run.Locate,1" 
           PLOC2D_located = "Run.Locate.Ok" 
			#textmsg("sent",PLOC2D_command) 
			PLOC2D_SendString(PLOC2D_command) 
       	#sleep(0.2) 
			PLOC2D_receivedPartMsg=socket_read_string("Sick_Ploc_Socket","","",False,120) 
					#textmsg(PLOC2D_receivedPartMsg) 
			PLOC2D_delimiter = "," 
			PLOC2D_l=0 
			l_token =0 
			PLOC2D_ok=-1 
			PLOC2D_data=[0,0,0,0,0,0,0,0,0] 
			PLOC2D_pos=0 
			PLOC2D_token=" " 
			s_length = str_len(PLOC2D_receivedPartMsg) 
			first=True 
			while PLOC2D_ok!= 0: 
				PLOC2D_pos = str_find(PLOC2D_receivedPartMsg,PLOC2D_delimiter) 
				if PLOC2D_pos==-1: 
					PLOC2D_token = PLOC2D_receivedPartMsg 
					PLOC2D_ok=0 
					#textmsg(PLOC2D_data) 
				else: 
					PLOC2D_token = str_sub(PLOC2D_receivedPartMsg,0,PLOC2D_pos) 
					l_token = str_len(PLOC2D_token) 
					PLOC2D_receivedPartMsg=str_sub(PLOC2D_receivedPartMsg,l_token+1,s_length) 
				end 
				if first: 
					first=False 
					if PLOC2D_token == PLOC2D_located: 
						PLOC2D_data[0]=1 
					else: 
						PLOC2D_data[0]=0 
						break 
					end 
				end 
				if PLOC2D_l == 1: 
					PLOC2D_data[1] = to_num(PLOC2D_token) 
				elif PLOC2D_l == 4: 
					PLOC2D_data[2] = to_num(PLOC2D_token) 
				elif PLOC2D_l == 5: 
					PLOC2D_data[3] = to_num(PLOC2D_token) 
				elif PLOC2D_l == 6: 
					PLOC2D_data[4] = to_num(PLOC2D_token) 
				elif PLOC2D_l == 7: 
					PLOC2D_data[5] = to_num(PLOC2D_token) 
				elif PLOC2D_l == 8: 
					PLOC2D_data[6] = to_num(PLOC2D_token) 
				elif PLOC2D_l == 9: 
					PLOC2D_data[7] = to_num(PLOC2D_token) 
				elif PLOC2D_l == 3: 
					PLOC2D_data[8] = to_num(PLOC2D_token) 
				end 
				PLOC2D_l=PLOC2D_l+1 
			end 
			return PLOC2D_data 
		end 
		def PLOC2D_extractPose(PLOC2D_PartData):  #Function extracting a meaningful pose from the part result data obtained from PLOC. 
			PLOC2D_correctionFrame=PLOC2D_PartData 
			PLOC2D_correctionFrame[2]=PLOC2D_PartData[2]/1 
			PLOC2D_correctionFrame[3]=PLOC2D_PartData[3]/1 
			PLOC2D_correctionFrame[4]=PLOC2D_PartData[4]/1 
			PLOC2D_URPose=PLOC2D_convertPose(PLOC2D_correctionFrame) 
			return PLOC2D_URPose 
		end 
		def PLOC2D_getCorrectedPickPose(PLOC2D_PartData,PLOC_AlignmentF): 
			PLOC2D_correctionFrame=PLOC2D_extractPose(PLOC2D_PartData) 
			PLOC2D_correctedFrame=pose_trans(PLOC_AlignmentF,PLOC2D_correctionFrame) 
			#textmsg(PLOC2D_correctedFrame) 
			return PLOC2D_correctedFrame 
		end 
		def Connect_To_ANYFEEDER(PLOC2D_ip,PLOC2D_port): #Function to establish socket connection with PLOC 
			PLOC2D_AnyfeederConnected = False 
			PLOC2D_AnyfeederCounter=0 
			while not PLOC2D_AnyfeederConnected and (PLOC2D_AnyfeederCounter<100): 
	  			PLOC2D_AnyfeederConnected=socket_open(PLOC2D_ip,PLOC2D_port,"Anyfeeder_Socket") 
	  			PLOC2D_AnyfeederCounter=PLOC2D_AnyfeederCounter+1 
			end 
			if PLOC2D_AnyfeederCounter>=100: 
	  			popup("Connection to anyfeeder failed","Time out",False,True,blocking=True) 
	  			halt 
			else: 
	  			#textmsg("Connected to Anyfeeder") 
				ANYFEEDER_CONNECTION = "Connected to Anyfeeder" 			end 
		end	 
		def Connect_To_PLOC(PLOC2D_ip,PLOC2D_port): #Function to establish socket connection with PLOC 
			PLOC2D_Connected = False 
			PLOC2D_counter=0 
			while not PLOC2D_Connected and (PLOC2D_counter<100): 
	  			PLOC2D_Connected=socket_open(PLOC2D_ip,PLOC2D_port,"Sick_Ploc_Socket") 
	  			PLOC2D_counter=PLOC2D_counter+1 
			end 
			if PLOC2D_counter>=100: 
	  			popup("Connection to PLOC failed","Time out",False,True,blocking=True) 
	  			halt 
			else: 
	  			#textmsg("Connected to PLOC") 
				PLOC2D_CONNECTION = "Connected to PLOC2D_" 			end 
		end	 
		def DISCONNECT_To_PLOC(): #Function to disconnect socket connection with PLOC 
			socket_close("Sick_Ploc_Socket") 
		end	 
		def DISCONNECT_To_ANYFEEDER(): #Function to disconnect socket connection with PLOC 
			socket_close("Anyfeeder_Socket") 
		end	 
		def PLOC2D_sendToAnyfeed(PLOC2D_AnyfeederCommand): #Function to ask PLOC2D_ to locate a part. INPUT= string PLOC2D_ job Alias. OUTPUT=list with received part result data 
			PLOC2D_SendStringToAnyfeeder(PLOC2D_AnyfeederCommand) 
       	#sleep(0.2) 
			PLOC2D_AnyfeederReceivedPartMsg=socket_read_string("Anyfeeder_Socket","","",False,120) 
			#textmsg(PLOC2D_AnyfeederReceivedPartMsg) 
			return PLOC2D_AnyfeederReceivedPartMsg 
		end	 
  # end: URCap Installation Node
  global PLOC_Ref=[0.000000,-1.570800,-1.570800,-1.745330,1.570800,1.570800]
  global PLOC_clear=p[0,0,0,0,0,0]
  global PLOC_pick=p[0,0,0,0,0,0]
  global PLOC_prepick=[0,0,0,0,0,0]
  global PLOC_total_33=0
  global PLOC_total_34=0
  global n_shapes=0
  global Start_p=p[.456474845785, -.121213972691, .087765322809, 2.225040991059, -2.208311442343, -.017870630558]
  global Start_q=[0.02565941959619522, -1.665295263329977, -2.110389471054077, -0.9505583208850403, 1.5772393941879272, 0.019363388419151306]
  $ 2 "BeforeStart"
  # begin: URCap Program Node
  #   Source: Robotiq_Grippers, 3.19.1.111718, Robotiq Inc.
  #   Type: Gripper Activate
  $ 3 "Gripper Activate"
  
  rq_set_max_current_for_all_grippers()
  
  reset_and_activate = False
  
  rq_activate_all_grippers(False)
  # end: URCap Program Node
  # begin: URCap Program Node
  #   Source: Robotiq_Grippers, 3.19.1.111718, Robotiq Inc.
  #   Type: Gripper
  $ 4 "Gripper Open (1)"
  gripper_slave_ids_0 = [9]
  popupErrorGripperWord = "Gripper"
  popupErrorNoConnection1 = "must be connected to run this program."
  popupErrorNoConnection2 = "No connection"
  popupErrorNotActivated1 = "is not activated. Go to Installation tab > Gripper to activate it and run the program again."
  popupErrorNotActivated2 = "Not activated"
  rq_gripper_speed = 100.0
  rq_gripper_force = 100.0
  rq_gripper_position = 0.0
  rq_is_blocking = True
  rq_is_robot_compliant = False
  nb_slave_ids = get_list_length(gripper_slave_ids_0)
  rq_wait_for_gripper_reconnection()
  index = 0
  while (index < nb_slave_ids):
      if (not rq_is_gripper_connected(gripper_slave_ids_0[index])):
          write_error_popup(index, popupErrorGripperWord, popupErrorNoConnection1, popupErrorNoConnection2)
      end
      index = index + 1
  end
  index = 0
  while (index < nb_slave_ids):
      if (not rq_is_gripper_activated(gripper_slave_ids_0[index])):
          write_error_popup(index, popupErrorGripperWord, popupErrorNotActivated1, popupErrorNotActivated2)
      end
      index = index + 1
  end
  rq_set_speed_norm_multi_grippers(rq_gripper_speed, gripper_slave_ids_0)
  rq_set_force_norm_multi_grippers(rq_gripper_force, gripper_slave_ids_0)
  if (rq_is_blocking):
      if rq_is_robot_compliant:
          zero_ftsensor()
          sleep(0.02)
          # Maximum allowed deviation values for non-compliant axes are default values generated by UR in a Force node
          force_mode(tool_pose(), [1, 1, 0, 0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], 2, [0.15, 0.15, 0.1, 0.3490658503988659, 0.3490658503988659, 0.3490658503988659])
      end
      rq_move_and_wait_norm_multi_grippers(rq_gripper_position, gripper_slave_ids_0)
      if rq_is_robot_compliant:
          end_force_mode()
      end
  else:
      rq_move_norm_multi_grippers(rq_gripper_position, gripper_slave_ids_0)
  end
  # end: URCap Program Node
  $ 5 "l≔make_list(42, 0)"
  global l=make_list(42, 0)
  $ 6 "open_socket≔socket_open('192.168.65.184', 8888, 'ur5e_pc')"
  global open_socket=socket_open("192.168.65.184", 8888, "ur5e_pc")
  $ 7 "Loop open_socket≟ False "
  while (open_socket ==   False  ):
    $ 8 "open_socket≔socket_open('192.168.65.184', 8888, 'ur5e_pc')"
    global open_socket=socket_open("192.168.65.184", 8888, "ur5e_pc")
  end
  $ 9 "placing_offset≔p[0,0,-0.02,0,0,0]"
  global placing_offset=p[0,0,-0.02,0,0,0]
  $ 10 "rpy_base≔rotvec2rpy([2.225, -2.208, 0])"
  global rpy_base=rotvec2rpy([2.225, -2.208, 0])
  $ 11 "orient≔[0,0,0]"
  global orient=[0,0,0]
  $ 12 "recv_i≔0"
  global recv_i=0
  $ 13 "i≔0"
  global i=0
  $ 14 "str_ack≔''"
  global str_ack=""
  $ 15 "is_receiving≔ False "
  global is_receiving=  False  
  $ 21 "Loop 7 times"
  Loop_2 = 0
  while (Loop_2 < 7):
    $ 22 "Loop str_ack≠'ACK'"
    while (str_ack != "ACK"):
      $ 23 "str_ack≔socket_read_string('ur5e_pc')"
      global str_ack=socket_read_string("ur5e_pc")
      $ 24 "Wait: 0.01"
      sleep(0.01)
    end
    $ 25 "socket_data≔socket_read_ascii_float(6,'ur5e_pc')"
    global socket_data=socket_read_ascii_float(6,"ur5e_pc")
    $ 26 "Loop socket_data[0]≠6"
    while (socket_data[0] != 6):
      $ 27 "socket_data≔socket_read_ascii_float(6,'ur5e_pc')"
      global socket_data=socket_read_ascii_float(6,"ur5e_pc")
      $ 28 "Wait: 0.1"
      sleep(0.1)
    end
    $ 29 "Loop recv_i<6"
    while (recv_i<6):
      $ 30 "l[i]=socket_data[recv_i+1]"
      l[i]=socket_data[recv_i+1]
      $ 31 "i≔i+1"
      global i=i+1
      $ 32 "recv_i≔recv_i+1"
      global recv_i=recv_i+1
    end
    $ 36 "recv_i≔0"
    global recv_i=0
    $ 37 "ack_send≔socket_send_string('ACK','ur5e_pc')"
    global ack_send=socket_send_string("ACK","ur5e_pc")
    $ 38 "Loop ack_send≟ False "
    while (ack_send ==   False  ):
      $ 39 "ack_send≔socket_send_string('ACK','ur5e_pc')"
      global ack_send=socket_send_string("ACK","ur5e_pc")
      $ 40 "Wait: 0.01"
      sleep(0.01)
    end
    Loop_2 = Loop_2 + 1
  end
  $ 43 "triangle_mid≔p[l[0],l[1],l[2],l[3],l[4],l[5]]"
  global triangle_mid=p[l[0],l[1],l[2],l[3],l[4],l[5]]
  $ 44 "triangle_s1≔p[l[6],l[7],l[8],l[9],l[10],l[11]]"
  global triangle_s1=p[l[6],l[7],l[8],l[9],l[10],l[11]]
  $ 45 "triangle_s2≔p[l[12],l[13],l[14],l[15],l[16],l[17]]"
  global triangle_s2=p[l[12],l[13],l[14],l[15],l[16],l[17]]
  $ 46 "triangle_big1≔p[l[18],l[19],l[20],l[21],l[22],l[23]]"
  global triangle_big1=p[l[18],l[19],l[20],l[21],l[22],l[23]]
  $ 47 "triangle_big2≔p[l[24],l[25],l[26],l[27],l[28],l[29]]"
  global triangle_big2=p[l[24],l[25],l[26],l[27],l[28],l[29]]
  $ 48 "square≔p[l[30],l[31],l[32],l[33],l[34],l[35]]"
  global square=p[l[30],l[31],l[32],l[33],l[34],l[35]]
  $ 49 "parallelogram≔p[l[36],l[37],l[38],l[39],l[40],l[41]]"
  global parallelogram=p[l[36],l[37],l[38],l[39],l[40],l[41]]
  $ 50 "cam_offset≔p[0.02,0,-0.025,0,0,1.570]"
  global cam_offset=p[0.02,0,-0.025,0,0,1.570]
  $ 51 "i≔0"
  global i=0
  $ 52 "n_shapes≔7"
  global n_shapes=7
  $ 53 "trgsm_n≔1"
  global trgsm_n=1
  $ 54 "trgbig_n≔1"
  global trgbig_n=1
  $ 55 "MoveJ"
  $ 56 "Start" "breakAfter"
  set_tcp(p[0.0,0.0,0.165,0.0,0.0,0.0])
  movej(get_inverse_kin(Start_p, qnear=Start_q), a=1.3962634015954636, v=1.0471975511965976, r=0.01)
  $ 57 "Robot Program"
  $ 58 "Loop i < n_shapes"
  while (i < n_shapes):
    # begin: URCap Program Node
    #   Source: PART LOCALIZATION WITH SICK PLOC2D, 3.0.0.100, SICK AG - Developed by Nimalendiran Kailasanathan
    #   Type: PLOC2D
    $ 60 "PLOC2D"
    activeTCP =p[0.0,0.0,0.165,0.0,0.0,0.0]
    PLOC_Ref=[0.642090,-1.790640,-2.202800,-0.733020,1.577610,0.627860]
    PLOC2D_STATUS = "Job(s) not located."
    PLOC2D_JOB_ID = 0
    PLOC_LOCATED = False
    PLOC_IS_WITHIN_REACH = False
    isPickAll =1
    PLOC2D_LOCATE_TRIALS = 0
    PLOC2D_ip ="192.168.65.216"
    Connect_To_PLOC(PLOC2D_ip,14158)
    global PLOC2D_AlignmentFrame = p[0.43363,0.17376,0.05179,2.21728,2.21672,-0.02909]
     PLOC2D_Timeout = 10
     enableAnyfeeder = 0
     enableLimitRotation = 0
    current_part_to_pick = 1
		alllocatedPartsSetOk=0
		PLOC2D_partLocated=0
 		ploc_located_parts=PLOC_total_33 
		ploc_matches=PLOC_total_34 
                   textmsg("PLOC2D_Timeout: ",PLOC2D_Timeout) 
	while PLOC2D_partLocated == 0:
					  	if isPickAll == 0: 
							ploc_located_parts = 1 
						end 
				if (ploc_located_parts > 1): 
					textmsg("current_part_to_pick: ",current_part_to_pick)
					textmsg("ploc_matches: ",ploc_matches)
        			runcmd = "Run.Locate, 1 2 3 4 5 " 
					next_to_pick=ploc_matches-ploc_located_parts+2 
					textmsg("next to pick: ",next_to_pick) 
					PLOC2D_Matches = str_cat(str_cat(runcmd,","),to_str(next_to_pick)) #specify the job to receive from PLOC 
					PLOC2D_PartData=PLOC2D_LocatePart(PLOC2D_Matches) 
 					ploc_located_parts = ploc_located_parts-1 
 					current_part_to_pick = current_part_to_pick+1 
				else: 
					PLOC2D_PartData=PLOC2D_LocatePart("Run.Locate, 1 2 3 4 5 ") 
          			ploc_located_parts = PLOC2D_PartData[8] #get the total number of located parts.
				end 
			PLOC2D_partLocated=PLOC2D_PartData[0] 
                   textmsg("ploc_located_parts: ",ploc_located_parts) 
				bOK1 = False     
		if PLOC2D_partLocated==1: 
				PLOC_LOCATED = True
				PLOC2D_status = str_cat(str_cat(" Job " ,PLOC2D_PartData[1] )," has been located.")  
				PLOC2D_JOB_ID = PLOC2D_PartData[1]  
				PLOC2D_STATUS = PLOC2D_status
				pickpoint1=get_actual_joint_positions()
				pickpoint2=get_actual_tcp_pose()
PLOC_prepick=pickpoint1 
PLOC_total_33=ploc_located_parts 
PLOC_total_34=PLOC2D_PartData[8] 
PLOC_pick=pickpoint2 
PLOC_clear=pickpoint2 
		    	PLOC2D_job=PLOC2D_PartData[1]
				PLOC2D_LOCATE_TRIALS = 0
				bOK1 = False
				bOK2 = False
     			PLOC2D_corrPickPose=PLOC2D_getCorrectedPickPose(PLOC2D_PartData,PLOC2D_AlignmentFrame) 
				PLOC2D_PrePick=pose_trans(PLOC2D_corrPickPose,p[0,0,-0.0,0,0,0]) 
				bOK1=get_inverse_kin_has_solution(PLOC2D_PrePick,PLOC_Ref,1e-10,1e-10,activeTCP) 
				if bOK1: 
					PLOC2D_PrePickJ=ploc2d_wrist(PLOC2D_PrePick,PLOC_Ref,activeTCP)
					bOK2=get_inverse_kin_has_solution(PLOC2D_corrPickPose,PLOC2D_PrePickJ,1e-10,1e-10,activeTCP) 
				end 
			if bOK2 and bOK1: 
				textmsg("robot is within reach: ") 
				if (enableLimitRotation == 1): 
        			rpx = 0.0
       			rpy = 0.0
       			rpz = 0.0
					theta = sqrt(PLOC2D_corrPickPose[3]*PLOC2D_corrPickPose[3] + PLOC2D_corrPickPose[4]*PLOC2D_corrPickPose[4]+PLOC2D_corrPickPose[5]*PLOC2D_corrPickPose[5])
					rAxN=[PLOC2D_corrPickPose[3]/theta, PLOC2D_corrPickPose[4]/theta, PLOC2D_corrPickPose[5]/theta]
        			px = PLOC2D_corrPickPose[0]
        			py = PLOC2D_corrPickPose[1]
        			pz = PLOC2D_corrPickPose[2]
        			rppx =rpx-px
        			rppy =rpy-py
        			rppz =rpz-pz
					zx=rAxN[0]*rAxN[2]*(1-cos(theta))+rAxN[1]*sin(theta)
					zy=rAxN[1]*rAxN[2]*(1-cos(theta))-rAxN[0]*sin(theta)
					zz=cos(theta)+rAxN[2]*rAxN[2]*(1-cos(theta))
        			zn = normalize([zx,zy,zz])
        			yx = zy*rppz-zz*rppy
        			yy = zz*rppx-zx*rppz
        			yz = zx*rppy-zy*rppx
        			yn = normalize([yx,yy,yz])
        			xx = yy*zz-yz*zy
        			xy = yz*zx-yx*zz
        			xz = yx*zy-yy*zx
        			xn = normalize([xx,xy,xz])
					thetaN=acos((xx+yy+zz-1)/2)
					rAxNew=[yz-zy,zx-xz,xy-yx]
					rAxNormNew=normalize(rAxNew)
					rAxAngleNew=[rAxNormNew[0]*thetaN,rAxNormNew[1]*thetaN,rAxNormNew[2]*thetaN]
        			PLOC2D_corrPickPose[3] = rAxAngleNew[0]
        			PLOC2D_corrPickPose[4] = rAxAngleNew[1]
        			PLOC2D_corrPickPose[5] = rAxAngleNew[2]
				end 
PLOC_prepick= PLOC2D_PrePickJ 
					PLOC2D_corrPickPose=ploc_wrist_pose(PLOC2D_corrPickPose,PLOC2D_PrePickJ,activeTCP)
PLOC_pick= PLOC2D_corrPickPose 
					PLOC2D_corrClearPose=ploc_wrist_pose(PLOC2D_PrePick,PLOC2D_PrePickJ,activeTCP)
PLOC_clear=PLOC2D_corrClearPose
			end 
	else: 
        	  		textmsg("Cannot reach position") 
				  	if (enableAnyfeeder == 1): 
						Connect_To_ANYFEEDER(PLOC2D_ip,2120)
       				sleep(1) 
						PLOC2D_AnyfeederReceivedPartMsg = PLOC2D_sendToAnyfeed("feed")
       				sleep(1) 
						DISCONNECT_To_ANYFEEDER()
					end 
					PLOC2D_LOCATE_TRIALS = PLOC2D_LOCATE_TRIALS+1 
					if (PLOC2D_LOCATE_TRIALS ==PLOC2D_Timeout):
						popup("No part found used all localization trials, program will stop", title="PLOC2D Localization trials!",blocking=True)
						halt
					end 
		end 
		sync() 
		end 
    DISCONNECT_To_PLOC()
    $ 61 "Folder" "noBreak"
    $ 62 "Pick and Place" "noBreak"
    $ 63 "Start" "noBreak"
    $ 64 "'Set start position and open gripper'" "noBreak"
    # 'Set start position and open gripper'
    $ 65 "MoveJ" "noBreak"
    $ 66 "Start" "noBreak"
    set_tcp(p[0.0,0.0,0.165,0.0,0.0,0.0])
    movej(get_inverse_kin(Start_p, qnear=Start_q), a=1.3962634015954636, v=1.0471975511965976, r=0.01)
    $ 69 "Approach" "noBreak"
    $ 70 "MoveJ" "noBreak"
    $ 71 "PLOC_prepick" "noBreak"
    set_tcp(p[0.0,0.0,0.165,0.0,0.0,0.0])
    movej(PLOC_prepick, a=1.3962634015954636, v=1.0471975511965976, r=0.01)
    $ 72 "Pick" "noBreak"
    $ 73 "PLOC_pick≔pose_add(PLOC_pick,cam_offset)" "noBreak"
    global PLOC_pick=pose_add(PLOC_pick,cam_offset)
    $ 74 "MoveL" "noBreak"
    $ 75 "PLOC_pick" "noBreak"
    set_tcp(p[0.0,0.0,0.165,0.0,0.0,0.0])
    movel(PLOC_pick, a=1.2, v=0.25)
    # begin: URCap Program Node
    #   Source: Robotiq_Grippers, 3.19.1.111718, Robotiq Inc.
    #   Type: Gripper
    $ 77 "Gripper Close (1)" "noBreak"
    gripper_slave_ids_1 = [9]
    popupErrorGripperWord = "Gripper"
    popupErrorNoConnection1 = "must be connected to run this program."
    popupErrorNoConnection2 = "No connection"
    popupErrorNotActivated1 = "is not activated. Go to Installation tab > Gripper to activate it and run the program again."
    popupErrorNotActivated2 = "Not activated"
    rq_gripper_speed = 100.0
    rq_gripper_force = 100.0
    rq_gripper_position = 100.0
    rq_is_blocking = True
    rq_is_robot_compliant = False
    nb_slave_ids = get_list_length(gripper_slave_ids_1)
    rq_wait_for_gripper_reconnection()
    index = 0
    while (index < nb_slave_ids):
        if (not rq_is_gripper_connected(gripper_slave_ids_1[index])):
            write_error_popup(index, popupErrorGripperWord, popupErrorNoConnection1, popupErrorNoConnection2)
        end
        index = index + 1
    end
    index = 0
    while (index < nb_slave_ids):
        if (not rq_is_gripper_activated(gripper_slave_ids_1[index])):
            write_error_popup(index, popupErrorGripperWord, popupErrorNotActivated1, popupErrorNotActivated2)
        end
        index = index + 1
    end
    rq_set_speed_norm_multi_grippers(rq_gripper_speed, gripper_slave_ids_1)
    rq_set_force_norm_multi_grippers(rq_gripper_force, gripper_slave_ids_1)
    if (rq_is_blocking):
        if rq_is_robot_compliant:
            zero_ftsensor()
            sleep(0.02)
            # Maximum allowed deviation values for non-compliant axes are default values generated by UR in a Force node
            force_mode(tool_pose(), [1, 1, 0, 0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], 2, [0.15, 0.15, 0.1, 0.3490658503988659, 0.3490658503988659, 0.3490658503988659])
        end
        rq_move_and_wait_norm_multi_grippers(rq_gripper_position, gripper_slave_ids_1)
        if rq_is_robot_compliant:
            end_force_mode()
        end
    else:
        rq_move_norm_multi_grippers(rq_gripper_position, gripper_slave_ids_1)
    end
    # end: URCap Program Node
    $ 78 "Clear" "noBreak"
    $ 79 "'Close gripper'" "noBreak"
    # 'Close gripper'
    $ 80 "MoveL" "noBreak"
    $ 81 "PLOC_clear" "noBreak"
    set_tcp(p[0.0,0.0,0.165,0.0,0.0,0.0])
    movel(PLOC_clear, a=1.2, v=0.25, r=0.01)
    $ 82 "Place" "noBreak"
    $ 83 "'Set drop position and open gripper'" "noBreak"
    # 'Set drop position and open gripper'
    $ 84 "shitrobot≔PLOC2D_JOB_ID" "noBreak"
    global shitrobot=PLOC2D_JOB_ID
    $ 86 "If shitrobot ≟ 1" "noBreak"
    if (shitrobot  ==  1):
      $ 87 "orient≔rpy2rotvec(rpy_base+[0,0,triangle_mid[5]])" "noBreak"
      global orient=rpy2rotvec(rpy_base+[0,0,triangle_mid[5]])
      $ 88 "triangle_mid≔pose_add(triangle_mid, p[0,0,0,orient[0], orient[1], orient[2]])" "noBreak"
      global triangle_mid= pose_add (triangle_mid, p[0,0,0,orient[0], orient[1], orient[2]])
      $ 89 "MoveJ" "noBreak"
      $ 90 "triangle_mid" "noBreak"
      set_tcp(p[0.0,0.0,0.165,0.0,0.0,0.0])
      movej(triangle_mid, a=1.3962634015954636, v=1.0471975511965976)
      $ 91 "triangle_mid≔pose_add(triangle_mid, placing_offset)" "noBreak"
      global triangle_mid= pose_add (triangle_mid, placing_offset)
      $ 92 "MoveJ" "noBreak"
      $ 93 "triangle_mid" "noBreak"
      set_tcp(p[0.0,0.0,0.165,0.0,0.0,0.0])
      movej(triangle_mid, a=1.3962634015954636, v=1.0471975511965976)
      # begin: URCap Program Node
      #   Source: Robotiq_Grippers, 3.19.1.111718, Robotiq Inc.
      #   Type: Gripper
      $ 94 "Gripper Open (1)" "noBreak"
      gripper_slave_ids_2 = [9]
      popupErrorGripperWord = "Gripper"
      popupErrorNoConnection1 = "must be connected to run this program."
      popupErrorNoConnection2 = "No connection"
      popupErrorNotActivated1 = "is not activated. Go to Installation tab > Gripper to activate it and run the program again."
      popupErrorNotActivated2 = "Not activated"
      rq_gripper_speed = 100.0
      rq_gripper_force = 100.0
      rq_gripper_position = 0.0
      rq_is_blocking = True
      rq_is_robot_compliant = False
      nb_slave_ids = get_list_length(gripper_slave_ids_2)
      rq_wait_for_gripper_reconnection()
      index = 0
      while (index < nb_slave_ids):
          if (not rq_is_gripper_connected(gripper_slave_ids_2[index])):
              write_error_popup(index, popupErrorGripperWord, popupErrorNoConnection1, popupErrorNoConnection2)
          end
          index = index + 1
      end
      index = 0
      while (index < nb_slave_ids):
          if (not rq_is_gripper_activated(gripper_slave_ids_2[index])):
              write_error_popup(index, popupErrorGripperWord, popupErrorNotActivated1, popupErrorNotActivated2)
          end
          index = index + 1
      end
      rq_set_speed_norm_multi_grippers(rq_gripper_speed, gripper_slave_ids_2)
      rq_set_force_norm_multi_grippers(rq_gripper_force, gripper_slave_ids_2)
      if (rq_is_blocking):
          if rq_is_robot_compliant:
              zero_ftsensor()
              sleep(0.02)
              # Maximum allowed deviation values for non-compliant axes are default values generated by UR in a Force node
              force_mode(tool_pose(), [1, 1, 0, 0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], 2, [0.15, 0.15, 0.1, 0.3490658503988659, 0.3490658503988659, 0.3490658503988659])
          end
          rq_move_and_wait_norm_multi_grippers(rq_gripper_position, gripper_slave_ids_2)
          if rq_is_robot_compliant:
              end_force_mode()
          end
      else:
          rq_move_norm_multi_grippers(rq_gripper_position, gripper_slave_ids_2)
      end
      # end: URCap Program Node
    else:
      $ 95 "ElseIf shitrobot ≟ 2" "noBreak"
      if (shitrobot  ==  2):
        $ 96 "If trgsm_n≟1" "noBreak"
        if (trgsm_n == 1):
          $ 97 "orient≔rpy2rotvec(rpy_base+[0,0,triangle_s1[5]])" "noBreak"
          global orient=rpy2rotvec(rpy_base+[0,0,triangle_s1[5]])
          $ 98 "triangle_s1≔pose_add(triangle_s1, p[0,0,0,orient[0], orient[1], orient[2]])" "noBreak"
          global triangle_s1= pose_add (triangle_s1, p[0,0,0,orient[0], orient[1], orient[2]])
          $ 99 "MoveJ" "noBreak"
          $ 100 "triangle_s1" "noBreak"
          movej(triangle_s1, a=1.3962634015954636, v=1.0471975511965976)
          $ 101 "triangle_s1≔pose_add(triangle_s1, placing_offset)" "noBreak"
          global triangle_s1= pose_add (triangle_s1, placing_offset)
          $ 102 "MoveJ" "noBreak"
          $ 103 "triangle_s1" "noBreak"
          movej(triangle_s1, a=1.3962634015954636, v=1.0471975511965976)
          # begin: URCap Program Node
          #   Source: Robotiq_Grippers, 3.19.1.111718, Robotiq Inc.
          #   Type: Gripper
          $ 104 "Gripper Open (1)" "noBreak"
          gripper_slave_ids_3 = [9]
          popupErrorGripperWord = "Gripper"
          popupErrorNoConnection1 = "must be connected to run this program."
          popupErrorNoConnection2 = "No connection"
          popupErrorNotActivated1 = "is not activated. Go to Installation tab > Gripper to activate it and run the program again."
          popupErrorNotActivated2 = "Not activated"
          rq_gripper_speed = 100.0
          rq_gripper_force = 100.0
          rq_gripper_position = 0.0
          rq_is_blocking = True
          rq_is_robot_compliant = False
          nb_slave_ids = get_list_length(gripper_slave_ids_3)
          rq_wait_for_gripper_reconnection()
          index = 0
          while (index < nb_slave_ids):
              if (not rq_is_gripper_connected(gripper_slave_ids_3[index])):
                  write_error_popup(index, popupErrorGripperWord, popupErrorNoConnection1, popupErrorNoConnection2)
              end
              index = index + 1
          end
          index = 0
          while (index < nb_slave_ids):
              if (not rq_is_gripper_activated(gripper_slave_ids_3[index])):
                  write_error_popup(index, popupErrorGripperWord, popupErrorNotActivated1, popupErrorNotActivated2)
              end
              index = index + 1
          end
          rq_set_speed_norm_multi_grippers(rq_gripper_speed, gripper_slave_ids_3)
          rq_set_force_norm_multi_grippers(rq_gripper_force, gripper_slave_ids_3)
          if (rq_is_blocking):
              if rq_is_robot_compliant:
                  zero_ftsensor()
                  sleep(0.02)
                  # Maximum allowed deviation values for non-compliant axes are default values generated by UR in a Force node
                  force_mode(tool_pose(), [1, 1, 0, 0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], 2, [0.15, 0.15, 0.1, 0.3490658503988659, 0.3490658503988659, 0.3490658503988659])
              end
              rq_move_and_wait_norm_multi_grippers(rq_gripper_position, gripper_slave_ids_3)
              if rq_is_robot_compliant:
                  end_force_mode()
              end
          else:
              rq_move_norm_multi_grippers(rq_gripper_position, gripper_slave_ids_3)
          end
          # end: URCap Program Node
          $ 105 "trgsm_n≔trgsm_n+1" "noBreak"
          global trgsm_n=trgsm_n+1
        else:
          $ 106 "Else" "noBreak"
          $ 107 "orient≔rpy2rotvec(rpy_base+[0,0,triangle_s2[5]])" "noBreak"
          global orient=rpy2rotvec(rpy_base+[0,0,triangle_s2[5]])
          $ 108 "triangle_s2≔pose_add(triangle_s2, p[0,0,0,orient[0], orient[1], orient[2]])" "noBreak"
          global triangle_s2= pose_add (triangle_s2, p[0,0,0,orient[0], orient[1], orient[2]])
          $ 109 "MoveJ" "noBreak"
          $ 110 "triangle_s2" "noBreak"
          movej(triangle_s2, a=1.3962634015954636, v=1.0471975511965976)
          $ 111 "triangle_s2≔pose_add(triangle_s1, placing_offset)" "noBreak"
          global triangle_s2= pose_add (triangle_s1, placing_offset)
          $ 112 "MoveJ" "noBreak"
          $ 113 "triangle_s2" "noBreak"
          movej(triangle_s2, a=1.3962634015954636, v=1.0471975511965976)
          # begin: URCap Program Node
          #   Source: Robotiq_Grippers, 3.19.1.111718, Robotiq Inc.
          #   Type: Gripper
          $ 114 "Gripper Open (1)" "noBreak"
          gripper_slave_ids_4 = [9]
          popupErrorGripperWord = "Gripper"
          popupErrorNoConnection1 = "must be connected to run this program."
          popupErrorNoConnection2 = "No connection"
          popupErrorNotActivated1 = "is not activated. Go to Installation tab > Gripper to activate it and run the program again."
          popupErrorNotActivated2 = "Not activated"
          rq_gripper_speed = 100.0
          rq_gripper_force = 100.0
          rq_gripper_position = 0.0
          rq_is_blocking = True
          rq_is_robot_compliant = False
          nb_slave_ids = get_list_length(gripper_slave_ids_4)
          rq_wait_for_gripper_reconnection()
          index = 0
          while (index < nb_slave_ids):
              if (not rq_is_gripper_connected(gripper_slave_ids_4[index])):
                  write_error_popup(index, popupErrorGripperWord, popupErrorNoConnection1, popupErrorNoConnection2)
              end
              index = index + 1
          end
          index = 0
          while (index < nb_slave_ids):
              if (not rq_is_gripper_activated(gripper_slave_ids_4[index])):
                  write_error_popup(index, popupErrorGripperWord, popupErrorNotActivated1, popupErrorNotActivated2)
              end
              index = index + 1
          end
          rq_set_speed_norm_multi_grippers(rq_gripper_speed, gripper_slave_ids_4)
          rq_set_force_norm_multi_grippers(rq_gripper_force, gripper_slave_ids_4)
          if (rq_is_blocking):
              if rq_is_robot_compliant:
                  zero_ftsensor()
                  sleep(0.02)
                  # Maximum allowed deviation values for non-compliant axes are default values generated by UR in a Force node
                  force_mode(tool_pose(), [1, 1, 0, 0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], 2, [0.15, 0.15, 0.1, 0.3490658503988659, 0.3490658503988659, 0.3490658503988659])
              end
              rq_move_and_wait_norm_multi_grippers(rq_gripper_position, gripper_slave_ids_4)
              if rq_is_robot_compliant:
                  end_force_mode()
              end
          else:
              rq_move_norm_multi_grippers(rq_gripper_position, gripper_slave_ids_4)
          end
          # end: URCap Program Node
        end
      else:
        $ 115 "ElseIf shitrobot ≟ 3" "noBreak"
        if (shitrobot  ==  3):
          $ 119 "If trgbig_n≟1" "noBreak"
          if (trgbig_n == 1):
            $ 120 "orient≔rpy2rotvec(rpy_base+[0,0,triangle_big1[5]])" "noBreak"
            global orient=rpy2rotvec(rpy_base+[0,0,triangle_big1[5]])
            $ 121 "triangle_big1≔pose_add(triangle_big1, p[0,0,0,orient[0], orient[1], orient[2]])" "noBreak"
            global triangle_big1= pose_add (triangle_big1, p[0,0,0,orient[0], orient[1], orient[2]])
            $ 122 "MoveJ" "noBreak"
            $ 123 "triangle_big1" "noBreak"
            movej(triangle_big1, a=1.3962634015954636, v=1.0471975511965976)
            $ 124 "triangle_big1≔pose_add(triangle_big1, placing_offset)" "noBreak"
            global triangle_big1= pose_add (triangle_big1, placing_offset)
            $ 125 "MoveJ" "noBreak"
            $ 126 "triangle_big1" "noBreak"
            movej(triangle_big1, a=1.3962634015954636, v=1.0471975511965976)
            # begin: URCap Program Node
            #   Source: Robotiq_Grippers, 3.19.1.111718, Robotiq Inc.
            #   Type: Gripper
            $ 127 "Gripper Open (1)" "noBreak"
            gripper_slave_ids_5 = [9]
            popupErrorGripperWord = "Gripper"
            popupErrorNoConnection1 = "must be connected to run this program."
            popupErrorNoConnection2 = "No connection"
            popupErrorNotActivated1 = "is not activated. Go to Installation tab > Gripper to activate it and run the program again."
            popupErrorNotActivated2 = "Not activated"
            rq_gripper_speed = 100.0
            rq_gripper_force = 100.0
            rq_gripper_position = 0.0
            rq_is_blocking = True
            rq_is_robot_compliant = False
            nb_slave_ids = get_list_length(gripper_slave_ids_5)
            rq_wait_for_gripper_reconnection()
            index = 0
            while (index < nb_slave_ids):
                if (not rq_is_gripper_connected(gripper_slave_ids_5[index])):
                    write_error_popup(index, popupErrorGripperWord, popupErrorNoConnection1, popupErrorNoConnection2)
                end
                index = index + 1
            end
            index = 0
            while (index < nb_slave_ids):
                if (not rq_is_gripper_activated(gripper_slave_ids_5[index])):
                    write_error_popup(index, popupErrorGripperWord, popupErrorNotActivated1, popupErrorNotActivated2)
                end
                index = index + 1
            end
            rq_set_speed_norm_multi_grippers(rq_gripper_speed, gripper_slave_ids_5)
            rq_set_force_norm_multi_grippers(rq_gripper_force, gripper_slave_ids_5)
            if (rq_is_blocking):
                if rq_is_robot_compliant:
                    zero_ftsensor()
                    sleep(0.02)
                    # Maximum allowed deviation values for non-compliant axes are default values generated by UR in a Force node
                    force_mode(tool_pose(), [1, 1, 0, 0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], 2, [0.15, 0.15, 0.1, 0.3490658503988659, 0.3490658503988659, 0.3490658503988659])
                end
                rq_move_and_wait_norm_multi_grippers(rq_gripper_position, gripper_slave_ids_5)
                if rq_is_robot_compliant:
                    end_force_mode()
                end
            else:
                rq_move_norm_multi_grippers(rq_gripper_position, gripper_slave_ids_5)
            end
            # end: URCap Program Node
            $ 128 "trgbig_n≔trgbig_n+1" "noBreak"
            global trgbig_n=trgbig_n+1
          else:
            $ 129 "Else" "noBreak"
            $ 130 "orient≔rpy2rotvec(rpy_base+[0,0,triangle_big2[5]])" "noBreak"
            global orient=rpy2rotvec(rpy_base+[0,0,triangle_big2[5]])
            $ 131 "triangle_big2≔pose_add(triangle_big2, p[0,0,0,orient[0], orient[1], orient[2]])" "noBreak"
            global triangle_big2= pose_add (triangle_big2, p[0,0,0,orient[0], orient[1], orient[2]])
            $ 132 "MoveJ" "noBreak"
            $ 133 "triangle_big2" "noBreak"
            movej(triangle_big2, a=1.3962634015954636, v=1.0471975511965976)
            $ 134 "triangle_big2≔pose_add(triangle_big2, placing_offset)" "noBreak"
            global triangle_big2= pose_add (triangle_big2, placing_offset)
            $ 135 "MoveJ" "noBreak"
            $ 136 "triangle_big2" "noBreak"
            movej(triangle_big2, a=1.3962634015954636, v=1.0471975511965976)
            # begin: URCap Program Node
            #   Source: Robotiq_Grippers, 3.19.1.111718, Robotiq Inc.
            #   Type: Gripper
            $ 137 "Gripper Open (1)" "noBreak"
            gripper_slave_ids_6 = [9]
            popupErrorGripperWord = "Gripper"
            popupErrorNoConnection1 = "must be connected to run this program."
            popupErrorNoConnection2 = "No connection"
            popupErrorNotActivated1 = "is not activated. Go to Installation tab > Gripper to activate it and run the program again."
            popupErrorNotActivated2 = "Not activated"
            rq_gripper_speed = 100.0
            rq_gripper_force = 100.0
            rq_gripper_position = 0.0
            rq_is_blocking = True
            rq_is_robot_compliant = False
            nb_slave_ids = get_list_length(gripper_slave_ids_6)
            rq_wait_for_gripper_reconnection()
            index = 0
            while (index < nb_slave_ids):
                if (not rq_is_gripper_connected(gripper_slave_ids_6[index])):
                    write_error_popup(index, popupErrorGripperWord, popupErrorNoConnection1, popupErrorNoConnection2)
                end
                index = index + 1
            end
            index = 0
            while (index < nb_slave_ids):
                if (not rq_is_gripper_activated(gripper_slave_ids_6[index])):
                    write_error_popup(index, popupErrorGripperWord, popupErrorNotActivated1, popupErrorNotActivated2)
                end
                index = index + 1
            end
            rq_set_speed_norm_multi_grippers(rq_gripper_speed, gripper_slave_ids_6)
            rq_set_force_norm_multi_grippers(rq_gripper_force, gripper_slave_ids_6)
            if (rq_is_blocking):
                if rq_is_robot_compliant:
                    zero_ftsensor()
                    sleep(0.02)
                    # Maximum allowed deviation values for non-compliant axes are default values generated by UR in a Force node
                    force_mode(tool_pose(), [1, 1, 0, 0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], 2, [0.15, 0.15, 0.1, 0.3490658503988659, 0.3490658503988659, 0.3490658503988659])
                end
                rq_move_and_wait_norm_multi_grippers(rq_gripper_position, gripper_slave_ids_6)
                if rq_is_robot_compliant:
                    end_force_mode()
                end
            else:
                rq_move_norm_multi_grippers(rq_gripper_position, gripper_slave_ids_6)
            end
            # end: URCap Program Node
          end
          $ 138 "MoveJ" "noBreak"
          $ 139 "triangle_big1" "noBreak"
          movej(triangle_big1, a=1.3962634015954636, v=1.0471975511965976)
          # begin: URCap Program Node
          #   Source: Robotiq_Grippers, 3.19.1.111718, Robotiq Inc.
          #   Type: Gripper
          $ 140 "Gripper Open (1)" "noBreak"
          gripper_slave_ids_7 = [9]
          popupErrorGripperWord = "Gripper"
          popupErrorNoConnection1 = "must be connected to run this program."
          popupErrorNoConnection2 = "No connection"
          popupErrorNotActivated1 = "is not activated. Go to Installation tab > Gripper to activate it and run the program again."
          popupErrorNotActivated2 = "Not activated"
          rq_gripper_speed = 100.0
          rq_gripper_force = 100.0
          rq_gripper_position = 0.0
          rq_is_blocking = True
          rq_is_robot_compliant = False
          nb_slave_ids = get_list_length(gripper_slave_ids_7)
          rq_wait_for_gripper_reconnection()
          index = 0
          while (index < nb_slave_ids):
              if (not rq_is_gripper_connected(gripper_slave_ids_7[index])):
                  write_error_popup(index, popupErrorGripperWord, popupErrorNoConnection1, popupErrorNoConnection2)
              end
              index = index + 1
          end
          index = 0
          while (index < nb_slave_ids):
              if (not rq_is_gripper_activated(gripper_slave_ids_7[index])):
                  write_error_popup(index, popupErrorGripperWord, popupErrorNotActivated1, popupErrorNotActivated2)
              end
              index = index + 1
          end
          rq_set_speed_norm_multi_grippers(rq_gripper_speed, gripper_slave_ids_7)
          rq_set_force_norm_multi_grippers(rq_gripper_force, gripper_slave_ids_7)
          if (rq_is_blocking):
              if rq_is_robot_compliant:
                  zero_ftsensor()
                  sleep(0.02)
                  # Maximum allowed deviation values for non-compliant axes are default values generated by UR in a Force node
                  force_mode(tool_pose(), [1, 1, 0, 0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], 2, [0.15, 0.15, 0.1, 0.3490658503988659, 0.3490658503988659, 0.3490658503988659])
              end
              rq_move_and_wait_norm_multi_grippers(rq_gripper_position, gripper_slave_ids_7)
              if rq_is_robot_compliant:
                  end_force_mode()
              end
          else:
              rq_move_norm_multi_grippers(rq_gripper_position, gripper_slave_ids_7)
          end
          # end: URCap Program Node
        else:
          $ 141 "ElseIf shitrobot ≟ 4" "noBreak"
          if (shitrobot  ==  4):
            $ 142 "orient≔rpy2rotvec(rpy_base+[0,0,square[5]])" "noBreak"
            global orient=rpy2rotvec(rpy_base+[0,0,square[5]])
            $ 143 "square≔pose_add(square, p[0,0,0,orient[0], orient[1], orient[2]])" "noBreak"
            global square= pose_add (square, p[0,0,0,orient[0], orient[1], orient[2]])
            $ 144 "MoveJ" "noBreak"
            $ 145 "square" "noBreak"
            set_tcp(p[0.0,0.0,0.165,0.0,0.0,0.0])
            movej(square, a=1.3962634015954636, v=1.0471975511965976)
            $ 146 "square≔pose_add(square, placing_offset)" "noBreak"
            global square= pose_add (square, placing_offset)
            $ 147 "MoveJ" "noBreak"
            $ 148 "square" "noBreak"
            movej(square, a=1.3962634015954636, v=1.0471975511965976)
            # begin: URCap Program Node
            #   Source: Robotiq_Grippers, 3.19.1.111718, Robotiq Inc.
            #   Type: Gripper
            $ 149 "Gripper Open (1)" "noBreak"
            gripper_slave_ids_8 = [9]
            popupErrorGripperWord = "Gripper"
            popupErrorNoConnection1 = "must be connected to run this program."
            popupErrorNoConnection2 = "No connection"
            popupErrorNotActivated1 = "is not activated. Go to Installation tab > Gripper to activate it and run the program again."
            popupErrorNotActivated2 = "Not activated"
            rq_gripper_speed = 100.0
            rq_gripper_force = 100.0
            rq_gripper_position = 0.0
            rq_is_blocking = True
            rq_is_robot_compliant = False
            nb_slave_ids = get_list_length(gripper_slave_ids_8)
            rq_wait_for_gripper_reconnection()
            index = 0
            while (index < nb_slave_ids):
                if (not rq_is_gripper_connected(gripper_slave_ids_8[index])):
                    write_error_popup(index, popupErrorGripperWord, popupErrorNoConnection1, popupErrorNoConnection2)
                end
                index = index + 1
            end
            index = 0
            while (index < nb_slave_ids):
                if (not rq_is_gripper_activated(gripper_slave_ids_8[index])):
                    write_error_popup(index, popupErrorGripperWord, popupErrorNotActivated1, popupErrorNotActivated2)
                end
                index = index + 1
            end
            rq_set_speed_norm_multi_grippers(rq_gripper_speed, gripper_slave_ids_8)
            rq_set_force_norm_multi_grippers(rq_gripper_force, gripper_slave_ids_8)
            if (rq_is_blocking):
                if rq_is_robot_compliant:
                    zero_ftsensor()
                    sleep(0.02)
                    # Maximum allowed deviation values for non-compliant axes are default values generated by UR in a Force node
                    force_mode(tool_pose(), [1, 1, 0, 0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], 2, [0.15, 0.15, 0.1, 0.3490658503988659, 0.3490658503988659, 0.3490658503988659])
                end
                rq_move_and_wait_norm_multi_grippers(rq_gripper_position, gripper_slave_ids_8)
                if rq_is_robot_compliant:
                    end_force_mode()
                end
            else:
                rq_move_norm_multi_grippers(rq_gripper_position, gripper_slave_ids_8)
            end
            # end: URCap Program Node
          else:
            $ 150 "ElseIf shitrobot ≟ 5" "noBreak"
            if (shitrobot  ==  5):
              $ 151 "orient≔rpy2rotvec(rpy_base+[0,0,parallelogram[5]])" "noBreak"
              global orient=rpy2rotvec(rpy_base+[0,0,parallelogram[5]])
              $ 152 "parallelogram≔pose_add(parallelogram, p[0,0,0,orient[0], orient[1], orient[2]])" "noBreak"
              global parallelogram= pose_add (parallelogram, p[0,0,0,orient[0], orient[1], orient[2]])
              $ 153 "MoveJ" "noBreak"
              $ 154 "parallelogram" "noBreak"
              set_tcp(p[0.0,0.0,0.165,0.0,0.0,0.0])
              movej(parallelogram, a=1.3962634015954636, v=1.0471975511965976)
              $ 155 "parallelogram≔pose_add(parallelogram, placing_offset)" "noBreak"
              global parallelogram= pose_add (parallelogram, placing_offset)
              $ 156 "MoveJ" "noBreak"
              $ 157 "parallelogram" "noBreak"
              movej(parallelogram, a=1.3962634015954636, v=1.0471975511965976)
              # begin: URCap Program Node
              #   Source: Robotiq_Grippers, 3.19.1.111718, Robotiq Inc.
              #   Type: Gripper
              $ 158 "Gripper Open (1)" "noBreak"
              gripper_slave_ids_9 = [9]
              popupErrorGripperWord = "Gripper"
              popupErrorNoConnection1 = "must be connected to run this program."
              popupErrorNoConnection2 = "No connection"
              popupErrorNotActivated1 = "is not activated. Go to Installation tab > Gripper to activate it and run the program again."
              popupErrorNotActivated2 = "Not activated"
              rq_gripper_speed = 100.0
              rq_gripper_force = 100.0
              rq_gripper_position = 0.0
              rq_is_blocking = True
              rq_is_robot_compliant = False
              nb_slave_ids = get_list_length(gripper_slave_ids_9)
              rq_wait_for_gripper_reconnection()
              index = 0
              while (index < nb_slave_ids):
                  if (not rq_is_gripper_connected(gripper_slave_ids_9[index])):
                      write_error_popup(index, popupErrorGripperWord, popupErrorNoConnection1, popupErrorNoConnection2)
                  end
                  index = index + 1
              end
              index = 0
              while (index < nb_slave_ids):
                  if (not rq_is_gripper_activated(gripper_slave_ids_9[index])):
                      write_error_popup(index, popupErrorGripperWord, popupErrorNotActivated1, popupErrorNotActivated2)
                  end
                  index = index + 1
              end
              rq_set_speed_norm_multi_grippers(rq_gripper_speed, gripper_slave_ids_9)
              rq_set_force_norm_multi_grippers(rq_gripper_force, gripper_slave_ids_9)
              if (rq_is_blocking):
                  if rq_is_robot_compliant:
                      zero_ftsensor()
                      sleep(0.02)
                      # Maximum allowed deviation values for non-compliant axes are default values generated by UR in a Force node
                      force_mode(tool_pose(), [1, 1, 0, 0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], 2, [0.15, 0.15, 0.1, 0.3490658503988659, 0.3490658503988659, 0.3490658503988659])
                  end
                  rq_move_and_wait_norm_multi_grippers(rq_gripper_position, gripper_slave_ids_9)
                  if rq_is_robot_compliant:
                      end_force_mode()
                  end
              else:
                  rq_move_norm_multi_grippers(rq_gripper_position, gripper_slave_ids_9)
              end
              # end: URCap Program Node
            end
          end
        end
      end
    end
    # end: URCap Program Node
    $ 159 "i≔i+1"
    global i=i+1
  end
  $ 160 "MoveJ"
  $ 161 "Start" "breakAfter"
  set_tcp(p[0.0,0.0,0.165,0.0,0.0,0.0])
  movej(get_inverse_kin(Start_p, qnear=Start_q), a=1.3962634015954636, v=1.0471975511965976, r=0.01)
end
